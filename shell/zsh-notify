# Zsh Notification Plugin
#   Sends OS X Alerts if a command runs longer than 30 seconds
#
#   Modified from Zsh-Notify (basically just concatenated the files):
#   https://github.com/marzocchi/zsh-notify
#
#   Caveat: If using Tmux, you're always notified
#
fpath=($fpath `dirname $0`)

# Default timeout is 30 seconds.
[[ $NOTIFY_COMMAND_COMPLETE_TIMEOUT == "" ]]  \
  && NOTIFY_COMMAND_COMPLETE_TIMEOUT=30

# Notify an error with no regard to the time elapsed (but always only
# when the terminal is in background).
function notify-error {
  local icon
  icon="/System/Library/CoreServices/CoreTypes.bundle/Contents/Resources/AlertStopIcon.icns"
  notify-if-background -t "#fail" --image "$icon" < /dev/stdin &!
}

# Notify of successful command termination, but only if it took at least
# 30 seconds (and if the terminal is in background).
function notify-success() {
  local now diff start_time last_command

  start_time=$1
  last_command="$2"
  now=`date "+%s"`

  ((diff = $now - $start_time ))
  if (( $diff > $NOTIFY_COMMAND_COMPLETE_TIMEOUT )); then
    notify-if-background -t "#win" <<< "$last_command" &!
  fi
}

# Notify about the last command's success or failure.
function notify-command-complete() {
  last_status=$?
  if [[ $last_status -gt "0" ]]; then
    notify-error <<< $last_command
  elif [[ -n $start_time ]]; then
    notify-success "$start_time" "$last_command"
  fi
  unset last_command start_time last_status
}

function store-command-stats() {
  last_command=$1
  last_command_name=${1[(wr)^(*=*|sudo|ssh|-*)]}
  start_time=`date "+%s"`
}


# vim: set nowrap filetype=zsh:
#
# Command iTerm2 from the shell by sending it "snippets" of AppleScript
# code.
#
# Examples:
#
#   echo 'set number of columns of terminal 2 to 80' | tell-iterm2
#
# Use the -tab option to target the current tab, eg.:
#
#   echo 'write text "ls -l" & return' | tell-iterm2 -tab
#
# Use the -d option to change the text item delimiter for the output,
# eg.:
#
#   echo '{name, tty}' | tell-iterm2 -tab
#   # Prints:
#   # default: echo (zsh), /dev/ttys018
#
#   echo '{name, tty}' | tell-iterm2 -tab -d "\n" 
#   # Prints:
#   # default: echo (zsh)
#   # /dev/ttys018
function tell-iterm2() {
    if [[ ! -x `which osascript` ]]; then
        echo "osascript not found -- not on a Mac?"
        return 1
    fi

    local tabvar term_running tab_found  delimcmd user_scpt ret
    typeset -A delimvar
    zparseopts -D tab=tabvar d:=delimvar

    # Quit on problem with options
    ret=$?
    if [[ $ret != 0 ]] return $ret

    if [[ $delimvar[-d] != "" ]]; then
        delimcmd=`cat <<DCMD
    set _result to result
    set Applescript's text item delimiters to "$delimvar"
    _result as text
    DCMD`
    fi

    term_running=`osascript <<OSA
    tell application "System Events"
        set c to count of (application processes whose bundle identifier is "com.googlecode.iterm2")
        return c
    end
    OSA`

    if [[ $term_running == 0 ]]; then
        echo "iTerm is not running!" >&2
        return 1
    fi

    user_scpt=`cat /dev/stdin`

    if [[ $tabvar == "-tab" ]]; then
      osascript <<OSA
      tell app "iTerm" 
        tell my find_tab("$TTY")
          $user_scpt
        end
        $delimcmd
      end
      to find_tab(tty_name)
        tell application "iTerm"
          first item of (sessions of current terminal whose tty is equal to tty_name)
        end tell
      end find_tab
OSA
    else
      osascript <<OSA
      tell app "iTerm" 
        $user_scpt
      end
      $delimcmd
OSA
    fi
}

# vim: set nowrap filetype=zsh:
#
# Post a notification using either Notification Center using
# terminal-notifier.app or Growl, through growlnotify.
#
# Notification is effectively posted only if the terminal application
# (either Terminal.app or iTerm2) is in background, or if the session tab
# is not active (or in other word when you are not looking at the shell). 
#
# Exits with status 1 if the terminal app is unsupported, or if the
# notifier program is not found.
#
# Exits with status 2 if the terminal is frontmost or the tab is active.
#
# Requirements:
#
# - terminal-notifier.app
#   https://github.com/alloy/terminal-notifier 
#
# - growlnotify
#   http://growl.info/extras.php/#growlnotify

function notify-if-background() {
    local term_id title icon_switch
    local -a otitle oicon
    zparseopts t:=otitle -icon:=oicon

    icon=$oicon[2]
    title=$otitle[2]
    message=$(<&0)

    [[ -z "$SYS_NOTIFIER" ]] \
      && SYS_NOTIFIER="/usr/local/bin/terminal-notifier"

    [[ -z "$GROWL_NOTIFIER" ]] \
      && GROWL_NOTIFIER="/usr/local/bin/growlnotify"

    if [[ "$TERM_PROGRAM" == 'iTerm.app' ]]; then
      term_id='com.googlecode.iterm2'
    elif [[ "$TERM_PROGRAM" == 'Apple_Terminal' ]]; then
      term_id='com.apple.terminal'
    else
      echo "Unsupported terminal: $TERM_PROGRAM" > /dev/stderr 
      return 1;
    fi

    if [[ $term_id == 'com.googlecode.iterm2' ]]; then
      TT='tell-iterm2'
      if [[ `$TT <<< "frontmost and (tty of (current session of current terminal) is equal to \"$TTY\")"` == "true" ]]; then
        return 2
      fi
    else
      TT='tell-terminal'
      if [[ `$TT <<<frontmost` == "true" && `$TT -tab <<<selected` == "true" ]]; then
        return 2
      fi
    fi

    #cat /dev/stdin | growlnotify "$@"
    # growlnotify "$@" < /dev/stdin


    if [[ -x "$SYS_NOTIFIER" ]]; then
      "$SYS_NOTIFIER" -activate "$term_id" -title "$title" -message "$message" 1>/dev/null 
    elif [[ -x "$GROWL_NOTIFIER" ]]; then
      [[ ! -z "$icon" ]] && icon_switch="--iconpath $icon"
      echo "$message" | "$GROWL_NOTIFIER" "$title" 
    else
      echo "No notifier program found." > /dev/stderr
      return 1
    fi
}

#autoload -U tell-terminal
#autoload -U tell-iterm2
#autoload -U notify-if-background
add-zsh-hook preexec store-command-stats
add-zsh-hook precmd notify-command-complete
